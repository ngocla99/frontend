import { NextResponse } from "next/server";
import { env } from "@/config/env";
import { STORAGE_BUCKETS } from "@/lib/constants/constant";
import { withSession } from "@/lib/middleware/with-session";
import {
	batchSignUrls,
	getSignedUrl,
} from "@/lib/utils/deduplicate-signed-urls";

/**
 * GET /api/baby/list - List user's baby images
 *
 * Query params:
 *   - user_id: Filter by user (optional, defaults to current user)
 *   - limit: Number of results (default: 20)
 *   - skip: Pagination offset (default: 0)
 */
export const GET = withSession(async ({ session, searchParams, supabase }) => {
	const userId = searchParams.user_id || session.user.id;
	const limit = parseInt(searchParams.limit || "20", 10);
	const skip = parseInt(searchParams.skip || "0", 10);

	// Get babies generated by the user
	const { data: babies, error: babiesError } = await supabase
		.from("babies")
		.select(`
        id,
        match_id,
        image_url,
        created_at,
        generated_by_profile_id,
        match:matches!babies_match_id_fkey (
          id,
          similarity_score,
          face_a:faces!matches_face_a_id_fkey (
            id,
            image_path,
            profile:profiles!faces_profile_id_fkey (
              id,
              name,
              gender,
              school
            )
          ),
          face_b:faces!matches_face_b_id_fkey (
            id,
            image_path,
            profile:profiles!faces_profile_id_fkey (
              id,
              name,
              gender,
              school
            )
          )
        )
      `)
		.eq("generated_by_profile_id", userId)
		.order("created_at", { ascending: false });

	if (babiesError) {
		throw babiesError;
	}

	// Group babies by match_id
	const babyGroups = new Map<string, any[]>();
	(babies || []).forEach((baby: any) => {
		if (!baby.match_id) return;

		if (!babyGroups.has(baby.match_id)) {
			babyGroups.set(baby.match_id, []);
		}
		babyGroups.get(baby.match_id)!.push(baby);
	});

	// OPTIMIZATION: Collect all unique image paths first
	const allImagePaths: string[] = [];

	for (const [, babyImages] of babyGroups.entries()) {
		const firstBaby = babyImages[0];
		const match = firstBaby.match;

		const imagePathA = match?.face_a?.image_path;
		const imagePathB = match?.face_b?.image_path;

		if (imagePathA) allImagePaths.push(imagePathA);
		if (imagePathB) allImagePaths.push(imagePathB);
	}

	// Batch sign all unique URLs at once
	const signedUrlMap = await batchSignUrls(
		supabase,
		STORAGE_BUCKETS.USER_IMAGES,
		allImagePaths,
		env.SUPABASE_SIGNED_URL_TTL,
	);

	// Format response using cached signed URLs
	const formattedBabies = Array.from(babyGroups.entries()).map(
		([matchId, babyImages]) => {
			const firstBaby = babyImages[0];
			const match = firstBaby.match;

			// Determine which profile is "me" and which is "other"
			const profileA = match?.face_a?.profile;
			const profileB = match?.face_b?.profile;
			const imagePathA = match?.face_a?.image_path;
			const imagePathB = match?.face_b?.image_path;

			const isProfileAMe = profileA?.id === userId;

			// Get signed URLs from cache
			const imageA = getSignedUrl(signedUrlMap, imagePathA) || "";
			const imageB = getSignedUrl(signedUrlMap, imagePathB) || "";

			return {
				id: matchId,
				me: {
					id: isProfileAMe ? profileA?.id || "" : profileB?.id || "",
					name: isProfileAMe ? profileA?.name || "" : profileB?.name || "",
					image: isProfileAMe ? imageA : imageB,
					school: isProfileAMe
						? profileA?.school || ""
						: profileB?.school || "",
				},
				other: {
					id: isProfileAMe ? profileB?.id || "" : profileA?.id || "",
					name: isProfileAMe ? profileB?.name || "" : profileA?.name || "",
					image: isProfileAMe ? imageB : imageA,
					school: isProfileAMe
						? profileB?.school || ""
						: profileA?.school || "",
				},
				created_at: firstBaby.created_at,
				images: babyImages.map((b: any) => ({
					id: b.id,
					image_url: b.image_url,
				})),
			};
		},
	);

	// Apply pagination to grouped results
	const paginatedBabies = formattedBabies.slice(skip, skip + limit);

	return NextResponse.json({
		babies: paginatedBabies,
		total: formattedBabies.length,
		skip,
		limit,
	});
});
